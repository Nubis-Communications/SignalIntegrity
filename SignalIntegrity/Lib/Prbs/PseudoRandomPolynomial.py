"""
 pseudo-random polynomial
"""

# Copyright (c) 2018 Teledyne LeCroy, Inc.
# All rights reserved worldwide.
#
# This file is part of SignalIntegrity.
#
# SignalIntegrity is free software: You can redistribute it and/or modify it under the terms
# of the GNU General Public License as published by the Free Software Foundation, either
# version 3 of the License, or any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this program.
# If not, see <https://www.gnu.org/licenses/>
import math

from SignalIntegrity.Lib.Exception import SignalIntegrityException

class PseudoRandomPolynomial(list):
    """generates pseudo-random bit patterns  
    list obtained from http://www.xilinx.com/support/documentation/application_notes/xapp052.pdf  
    This is a dictionary of polynomials.  The key is the polynomial order.  The list according to the key
    is the non-zero polynomial coefficients, of which there are order+1 of them.  
    For example, prbs2 is the polynomial x^2 + x^1 + 1, hence 2,1,0
    """
    polynomials={2:[2,1,0],
                 3:[3,2,0],
                 4:[4,3,0],
                 5:[5,3,0],
                 6:[6,5,0],
                 7:[7,6,0],
                 8:[8,6,5,4,0],
                 9:[9,5,0],
                 10:[10,7,0],
                 11:[11,9,0],
                 12:[12,11,10,4,0],
                 13:[13,12,11,8,0],
                 14:[14,13,12,2,0],
                 15:[15,14,0],
                 16:[16,15,13,4,0],
                 17:[17,14,0],
                 18:[18,11,0],
                 19:[19,18,17,14,0],
                 20:[20,17,0],
                 21:[21,19,0],
                 22:[22,21,0],
                 23:[23,18,0],
                 24:[24,23,22,17,0],
                 25:[25,22,0],
                 26:[26,6,2,1,0],
                 27:[27,5,2,1,0],
                 28:[28,25,0],
                 29:[29,27,0],
                 30:[30,6,4,1,0],
                 31:[31,28,0],
                 32:[32,22,2,1,0]}
    def __init__(self,polynomial):
        """constructor
        @param polynomial integer number or list of integer (1 or 0) of polynomial coefficients
        @remark if the polynomial parameter given is an integer, the polynomial is generated for that prbs integer number
        (i.e. prbs7 if 7 given).
        @remark the first element of the polynomial is for the zero power and is always 1.

        The second element is for power 1, the third element is power 2, etc.

        polynomials are found at https://en.wikipedia.org/wiki/Linear-feedback_shift_register
        """
        if isinstance(polynomial,int):
            number=polynomial
            if not number in self.polynomials:
                raise SignalIntegrityException('PseudoRandomPolynomial','pseudo-random polynomial not found')
            polynomial=[0 for _ in range(number+1)]
            for c in self.polynomials[number]: polynomial[c]=1
        list.__init__(self,polynomial)
    def Order(self):
        """Order
        @return integer polynomial order

        This is the length of the polynomial - 1
        """
        return len(self)-1
    def PatternLength(self):
        """PatternLength
        @return integer pattern length generated by polynomial.

        This is two raised to the polynomial order minus 1
        @see Order
        """
        return 2**self.Order()-1
    def Pattern(self,bits=None):
        """generate a list of pseudo-random bits according to the polynomial
        @param bits (optional, defaults to None) integer number of bits to return.
        If bits are specified, then the pattern returned will contain the number of bits specified.
        @return returns a list of integer (1 or 0) corresponding to the pattern.

        for an order P polynomial, the list of bits is 2^P-1 elements long, assuming bits are specified as None.
        """
        order = self.Order()
        length=self.PatternLength() if bits == None else min(self.PatternLength(),bits)
        pattern = [1 if k < order else 0 for k in range(length)]
        for i in range(order,length):
            pattern[i]=sum([self[order-p]*pattern[i-(order-p)] for p in range(order)])%2
        pattern = [(b+1)%2 for b in pattern]
        return pattern